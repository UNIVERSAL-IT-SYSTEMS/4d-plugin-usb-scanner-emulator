/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : usb-scanner-emulator
 #	author : miyako
 #	2016/03/02
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- debug

		case 1 :
			POST_TEXT(pResult, pParams);
			break;

	}
}

// ------------------------------------- debug ------------------------------------

#if VERSIONMAC

CGKeyCode VkKeyScan(UniChar c)
{
	switch (c)
    {
        case '0': return kVK_ANSI_Keypad0;
        case '1': return kVK_ANSI_Keypad1;
        case '2': return kVK_ANSI_Keypad2;
        case '3': return kVK_ANSI_Keypad3;
        case '4': return kVK_ANSI_Keypad4;
        case '5': return kVK_ANSI_Keypad5;
        case '6': return kVK_ANSI_Keypad6;
        case '7': return kVK_ANSI_Keypad7;
        case '8': return kVK_ANSI_Keypad8;
        case '9': return kVK_ANSI_Keypad9;

        case '=': return kVK_ANSI_KeypadEquals;
        case '-': return kVK_ANSI_KeypadMinus;
        case '+': return kVK_ANSI_KeypadPlus;
        case '*': return kVK_ANSI_KeypadMultiply;
        case '\n': return kVK_ANSI_KeypadEnter;
				
        case '\r': return kVK_Return;
        case '\t': return kVK_Tab;

        case ' ': return kVK_Space;
				
        case ')': return kVK_ANSI_RightBracket;
        case '(': return kVK_ANSI_LeftBracket;
        case ':': return kVK_ANSI_Quote;
        case ';': return kVK_ANSI_Semicolon;
        case '\\': return kVK_ANSI_Backslash;
        case ',': return kVK_ANSI_Comma;
        case '/': return kVK_ANSI_Slash;
        case '.': return kVK_ANSI_Period;
				
        case 'a': case 'A': return kVK_ANSI_A;
        case 'b': case 'B': return kVK_ANSI_B;
        case 'c': case 'C': return kVK_ANSI_C;
        case 'd': case 'D': return kVK_ANSI_D;
        case 'e': case 'E': return kVK_ANSI_E;
        case 'f': case 'F': return kVK_ANSI_F;
        case 'g': case 'G': return kVK_ANSI_G;
        case 'h': case 'H': return kVK_ANSI_H;
        case 'i': case 'I': return kVK_ANSI_I;
        case 'j': case 'J': return kVK_ANSI_J;
        case 'k': case 'K': return kVK_ANSI_K;
        case 'l': case 'L': return kVK_ANSI_L;
        case 'm': case 'M': return kVK_ANSI_M;
        case 'n': case 'N': return kVK_ANSI_N;
        case 'o': case 'O': return kVK_ANSI_O;
        case 'p': case 'P': return kVK_ANSI_P;
        case 'q': case 'Q': return kVK_ANSI_Q;
        case 'r': case 'R': return kVK_ANSI_R;
        case 's': case 'S': return kVK_ANSI_S;
        case 't': case 'T': return kVK_ANSI_T;
        case 'u': case 'U': return kVK_ANSI_U;
        case 'v': case 'V': return kVK_ANSI_V;
        case 'w': case 'W': return kVK_ANSI_W;
        case 'x': case 'X': return kVK_ANSI_X;
        case 'y': case 'Y': return kVK_ANSI_Y;
        case 'z': case 'Z': return kVK_ANSI_Z;
				
		default:
			return kVK_Command;//just a harmless place holder
	}
}
#endif

void POST_TEXT(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;

	Param1.fromParamAtIndex(pParams, 1);

	CUTF16String t;
	Param1.copyUTF16String(&t);
	
#if VERSIONMAC
	CGEventRef e;
	CGEventSourceRef eventSource = CGEventSourceCreate(kCGEventSourceStateHIDSystemState);
#else
	DWORD now = GetTickCount();
#endif
	
	
	for(unsigned int i = 0; i < t.length(); ++i)
	{
		PA_Unichar c = t.at(i);

		short code = VkKeyScan(c);

#if VERSIONWIN

    INPUT e[2];
		
		ZeroMemory(e, sizeof(e));
		e[0].type = e[1].type = INPUT_KEYBOARD;
		e[0].ki.wVk = e[1].ki.wVk = code;
		e[1].ki.dwFlags =KEYEVENTF_KEYUP;
		
		SendInput(2, e, sizeof(INPUT));

#else

		e = CGEventCreateKeyboardEvent (eventSource, (CGKeyCode)code, true);
		CGEventPost(kCGHIDEventTap, e);
		CFRelease(e);   
			 
		e = CGEventCreateKeyboardEvent (eventSource, (CGKeyCode)code, false);
		CGEventPost(kCGHIDEventTap, e);
		CFRelease(e);

#endif
	
	}
	
#if VERSIONMAC
	CFRelease(eventSource);
#endif
	
}

